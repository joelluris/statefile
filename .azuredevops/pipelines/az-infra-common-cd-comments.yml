# =========================
# Azure DevOps Pipeline
# - Security Scans on PR/CI
# - Prepare (Plan) on merge to main (publishes saved plan)
# - Apply saved plan with Environment approvals
# =========================

# ===== Triggers =====
trigger:
  branches:
    include:
      - integrations-networking

pr:
  autoCancel: true
  branches:
    include:
      - main  # PRs into main

# ===== Parameters & Variables =====
parameters:
- name: environment
  displayName: "Please Select Deployment Environment"
  type: string
  values:
  - dev
  - stg
  - prd
  - data
  - int

variables:
- group: TerraformSecrets  # keep TF_* and IDs here (no client secret/access key needed)
- name: TERRAFORM_VERSION
  value: 'latest'  # pin for plan/apply compatibility

# =========================================================
# Stage 1: Security Scans (Terrascan + Checkov) - runs on CI & PR
# =========================================================
stages:
- stage: Security_Scans
  displayName: "Run Terrascan & Checkov Scans"
  pool:
    name: az-infra-prod-pool-01
  jobs:
  - job: SecurityScanJob
    displayName: "Terraform Security Scan Job"
    steps:
      - checkout: self

      - task: TerraformInstaller@1
        displayName: "Install Latest Terraform"
        inputs:
          terraformVersion: "latest"

      - script: |
          set -e
          echo "Installing Terrascan v1.19.9..."
          curl -L https://github.com/tenable/terrascan/releases/download/v1.19.9/terrascan_1.19.9_Linux_x86_64.tar.gz -o terrascan.tar.gz
          tar -xvf terrascan.tar.gz terrascan
          sudo install terrascan /usr/local/bin
          rm -f terrascan terrascan.tar.gz
          terrascan version
        displayName: "Install Terrascan v1.19.9"

      - script: |
          set -e
          echo "Installing Checkov..."
          sudo apt-get update -y
          sudo apt-get install -y python3-pip
          pip3 install --upgrade pip
          pip3 install checkov
          checkov -v
        displayName: "Install Checkov"

      - script: |
          set -e
          echo "Creating artifact folder for scan results..."
          mkdir -p "$(System.DefaultWorkingDirectory)/scan-results"

          export TERRASCAN_HCL_EXPERIMENTS="module_variable_optional_attrs"

          shopt -s nullglob
          for m in terraform/modules/*; do
            [ -d "$m" ] || continue
            name=$(basename "$m")
            echo "=== Scanning module: $name ==="

            # Init module without backend
            (cd "$m" && terraform init -backend=false -input=false)

            module_path="$(Build.SourcesDirectory)/$m"

            # Terrascan (JUnit XML)
            terrascan scan -d "$module_path" \
              --policy-type azure \
              --iac-type terraform \
              --iac-version v14 \
              --output junit-xml \
              --show-passed > "$(System.DefaultWorkingDirectory)/scan-results/${name}-Terrascan-Report.xml" || true

            # Checkov (JUnit XML)
            checkov -d "$module_path" -o junitxml > "$(System.DefaultWorkingDirectory)/scan-results/${name}-Checkov-Report.xml" || true
          done
        displayName: "Run Terrascan & Checkov on Modules"

      - task: PublishTestResults@2
        displayName: "Publish JUnit Scan Results"
        inputs:
          testResultsFormat: "JUnit"
          testResultsFiles: "$(System.DefaultWorkingDirectory)/scan-results/*.xml"
          failTaskOnFailedTests: false
          testRunTitle: "IaC Security Scans (Terrascan & Checkov)"

# =========================================================
# Stage 2: Prepare (Plan) - only after merge to main, not PR
# Publishes:
#   - terraform-files (configuration + .terraform.lock.hcl)
#   - tfplan (the saved binary plan)
# =========================================================
- stage: Prepare_Terraform_Release
  displayName: "Prepare Artifact for Release"
  dependsOn: Security_Scans
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/integrations-networking'), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - job: Deployment
    displayName: "Terraform Deployment"
    pool:
      name: az-infra-prod-pool-01
      demands:
      - Agent.Name -equals azdevopsagent01
    steps:
      - checkout: self

      # Non-secret backend variables
      - task: Bash@3
        displayName: "Export Storage Backend Variables (no secrets)"
        inputs:
          targetType: inline
          script: |
            echo "##vso[task.setvariable variable=TF_STORAGE_RESOURCE_GROUP]$(TF_STORAGE_RESOURCE_GROUP)"
            echo "##vso[task.setvariable variable=TF_STORAGE_ACCOUNT_NAME]$(TF_STORAGE_ACCOUNT_NAME)"
            echo "##vso[task.setvariable variable=TF_CONTAINER_NAME]$(TF_CONTAINER_NAME)"

      - script: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq unzip curl rsync
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        displayName: "Install Dependencies"

      - script: |
          az --version
        displayName: "Verify Azure CLI Installation"

      - task: TerraformInstaller@1
        displayName: "Install Terraform"
        inputs:
          terraformVersion: "$(TERRAFORM_VERSION)"

      # Backend config pinned to PRD subscription (AAD auth)
      - script: |
          set +x
          cat > "$(Build.SourcesDirectory)/terraform/backend.tfvars" <<EOF
          subscription_id      = "$(SUBSCRIPTION_ID_PRD)"
          resource_group_name  = "$(TF_STORAGE_RESOURCE_GROUP)"
          storage_account_name = "$(TF_STORAGE_ACCOUNT_NAME)"
          container_name       = "$(TF_CONTAINER_NAME)"
          key                  = "${{ parameters.environment }}.tfstate"
          use_azuread_auth     = true
          EOF
          set -x
        displayName: "Write Backend Configuration (Azure AD auth - PRD subscription)"

      # Provider targeting: append env-subscription into tfvars so provider uses it
      - script: |
          set +x
          {
            echo 'tenant_id       = "$(TENANT_ID)"'
            echo 'subscription_id = "$(SUBSCRIPTION_ID_${{ parameters.environment }})"'
          } >> "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars"
          set -x
        displayName: "Append Non-Secret Auth Variables for Provider"
        continueOnError: true

      # 1) Terraform Init (backend must use PRD context)
      - task: AzureCLI@2
        displayName: "Terraform Init"
        inputs:
          azureSubscription: "az-infra-prod-ci"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            set -e
            az account set --subscription $(SUBSCRIPTION_ID_PRD)
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1

            echo "Account for backend (PRD):"
            az account show --query "{name:name, sub:id, tenant:tenantId}" -o tsv

            terraform -version
            terraform init -backend-config=backend.tfvars -reconfigure

      # 2) Terraform Validate (backend stays PRD)
      - task: AzureCLI@2
        displayName: "Terraform Validate"
        inputs:
          azureSubscription: "az-infra-prod-ci"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            set -e
            az account set --subscription $(SUBSCRIPTION_ID_PRD)
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1

            terraform validate -no-color

      # 3) Terraform Plan (backend PRD, provider uses env subscription via tfvars)
      - task: AzureCLI@2
        displayName: "Terraform Plan"
        inputs:
          azureSubscription: "az-infra-prod-ci"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            set -e
            az account set --subscription $(SUBSCRIPTION_ID_PRD)
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1

            terraform plan \
              -var-file="environments/${{ parameters.environment }}.tfvars" \
              -var="tf_storage_resource_group=$(TF_STORAGE_RESOURCE_GROUP)" \
              -var="tf_storage_account_name=$(TF_STORAGE_ACCOUNT_NAME)" \
              -var="tf_container_name=$(TF_CONTAINER_NAME)" \
              -input=false \
              -out=tfplan

      # Package the plan and config as separate Pipeline Artifacts
      - task: Bash@3
        displayName: "Stage plan & config for artifacts"
        inputs:
          targetType: inline
          script: |
            set -e
            mkdir -p "$(Build.ArtifactStagingDirectory)/tfplan"
            cp "$(Build.SourcesDirectory)/terraform/tfplan" "$(Build.ArtifactStagingDirectory)/tfplan/"

            mkdir -p "$(Build.ArtifactStagingDirectory)/terraform-files"
            # Include repo terraform config excluding the local .terraform dir
            rsync -a --delete \
              --exclude '.terraform/' \
              --exclude '*.plan' \
              "$(Build.SourcesDirectory)/terraform/" \
              "$(Build.ArtifactStagingDirectory)/terraform-files/"

      - task: PublishPipelineArtifact@1
        displayName: "Publish Pipeline Artifact: terraform-files"
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)/terraform-files"
          artifact: "terraform-files"
          publishLocation: "pipeline"

      - task: PublishPipelineArtifact@1
        displayName: "Publish Pipeline Artifact: tfplan"
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)/tfplan"
          artifact: "tfplan"
          publishLocation: "pipeline"

# =========================================================
# Stage 3: Terraform Apply (uses saved plan) - only after merge to main, not PR
# Bound to environment for approvals/checks: terraform-<env>
# =========================================================
# - stage: Terraform_Apply
#   displayName: "Terraform Apply"
#   dependsOn: Prepare_Terraform_Release
#   condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'), ne(variables['Build.Reason'], 'PullRequest'))
#   jobs:
#   - deployment: ApplyDeployment
#     displayName: "Apply Terraform Changes"
#     # This binds the job to an Azure DevOps Environment.
#     # Add Approvals & Checks in Pipelines > Environments to gate the apply.
#     environment: "MR-Approval-${{ parameters.environment }}"
#     pool:
#       name: az-infra-prod-pool-01
#       demands:
#       - Agent.Name -equals azdevopsagent01

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#             - checkout: none

#             # Download both artifacts published in the previous stage
#             - task: DownloadPipelineArtifact@2
#               displayName: "Download terraform-files"
#               inputs:
#                 buildType: current
#                 artifact: "terraform-files"
#                 targetPath: "$(Pipeline.Workspace)/terraform-files"

#             - task: DownloadPipelineArtifact@2
#               displayName: "Download tfplan"
#               inputs:
#                 buildType: current
#                 artifact: "tfplan"
#                 targetPath: "$(Pipeline.Workspace)/tfplan"

#             - script: |
#                 set -e
#                 sudo apt-get update -y
#                 sudo apt-get install -y jq unzip curl
#                 curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
#               displayName: "Install Dependencies (Azure CLI, tools)"

#             - script: |
#                 az --version
#               displayName: "Verify Azure CLI Installation"

#             - task: TerraformInstaller@1
#               displayName: "Install Terraform (Apply Stage)"
#               inputs:
#                 terraformVersion: "$(TERRAFORM_VERSION)"

#             # Recreate backend config locally for safety and determinism
#             - script: |
#                 set +x
#                 cat > "$(Pipeline.Workspace)/terraform-files/backend.tfvars" <<EOF
#                 subscription_id      = "$(SUBSCRIPTION_ID_PRD)"
#                 resource_group_name  = "$(TF_STORAGE_RESOURCE_GROUP)"
#                 storage_account_name = "$(TF_STORAGE_ACCOUNT_NAME)"
#                 container_name       = "$(TF_CONTAINER_NAME)"
#                 key                  = "${{ parameters.environment }}.tfstate"
#                 use_azuread_auth     = true
#                 EOF
#                 set -x
#               displayName: "Write Backend Configuration (Azure AD auth - PRD subscription)"

#             # ====== INIT (required before applying a saved plan) ======
#             - task: AzureCLI@2
#               displayName: "Terraform Init (backend in PRD)"
#               inputs:
#                 azureSubscription: "az-infra-prod-ci"
#                 scriptType: "bash"
#                 scriptLocation: "inlineScript"
#                 workingDirectory: "$(Pipeline.Workspace)/terraform-files"
#                 inlineScript: |
#                   set -e
#                   az account set --subscription $(SUBSCRIPTION_ID_PRD)
#                   export ARM_TENANT_ID=$(TENANT_ID)
#                   export TF_IN_AUTOMATION=1

#                   echo "Account for backend (PRD):"
#                   az account show --query "{name:name, sub:id, tenant:tenantId}" -o tsv

#                   terraform -version
#                   terraform init -backend-config=backend.tfvars -reconfigure

#             # Optional visibility: show what's in the saved plan
#             - task: AzureCLI@2
#               displayName: "Terraform Show (saved plan)"
#               inputs:
#                 azureSubscription: "az-infra-prod-ci"
#                 scriptType: "bash"
#                 scriptLocation: "inlineScript"
#                 workingDirectory: "$(Pipeline.Workspace)/terraform-files"
#                 inlineScript: |
#                   set -e
#                   terraform show -no-color "$(Pipeline.Workspace)/tfplan/tfplan" | tee plan.txt

#             - task: PublishPipelineArtifact@1
#               displayName: "Publish Plan Text for Audit"
#               inputs:
#                 targetPath: "$(Pipeline.Workspace)/terraform-files/plan.txt"
#                 artifact: "tfplan-text"
#                 publishLocation: "pipeline"

#             # ====== APPLY (consume the exact saved plan) ======
#             - task: AzureCLI@2
#               displayName: "Terraform Apply (using saved plan)"
#               inputs:
#                 azureSubscription: "az-infra-prod-ci"
#                 scriptType: "bash"
#                 scriptLocation: "inlineScript"
#                 workingDirectory: "$(Pipeline.Workspace)/terraform-files"
#                 inlineScript: |
#                   set -e
#                   az account set --subscription $(SUBSCRIPTION_ID_PRD)
#                   export ARM_TENANT_ID=$(TENANT_ID)
#                   export TF_IN_AUTOMATION=1

#                   terraform apply -input=false -auto-approve "$(Pipeline.Workspace)/tfplan/tfplan"
