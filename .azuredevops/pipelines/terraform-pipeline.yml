# =========================
# Azure DevOps Pipeline for Terraform Infrastructure Deployment
# 
# Pipeline Flow:
# 1. Security Scans - Runs on both PR and CI triggers using Terrascan & Checkov
# 2. Prepare (Plan) - Only on merge to main, creates and publishes Terraform plan artifacts
# 3. Apply - Uses saved plan with environment-based approvals for deployment
# =========================

# ===== Pipeline Triggers =====
# Trigger pipeline automatically when code is pushed to main branch
trigger:
  branches:
    include:
      - integrations-networking

pr:
  autoCancel: true
  branches:
    include:
      - main

# ===== Pipeline Parameters & Variables =====
# Runtime parameter allowing users to select which environment to deploy to
parameters:
- name: environment                                    # Parameter name used in code
  displayName: "Please Select Deployment Environment"  # Label shown in GUI
  type: string                                         # Data type
  default: nonprod                                     # Default environment
  values:                                              # The dropdown options
  - dev
  - stg
  - prd
  - data
  - int

# Pipeline variables configuration
# Import common variables (shared across all environments)
variables:
- template: ../templates/variables/common-variables.yml

# Import backend state storage variables (used by all environments)
- template: ../templates/variables/backend-variables.yml

# Import environment-specific variables based on runtime parameter
- ${{ if eq(parameters.environment, 'dev') }}:
  - template: ../templates/variables/dev-variables.yml
- ${{ if eq(parameters.environment, 'stg') }}:
  - template: ../templates/variables/stg-variables.yml
- ${{ if eq(parameters.environment, 'prd') }}:
  - template: ../templates/variables/prd-variables.yml
- ${{ if eq(parameters.environment, 'data') }}:
  - template: ../templates/variables/data-variables.yml
- ${{ if eq(parameters.environment, 'int') }}:
  - template: ../templates/variables/int-variables.yml
- ${{ if eq(parameters.environment, 'nonprod') }}:
  - template: ../templates/variables/nonprod-variables.yml

# Default pool for all jobs (can be overridden at job level if needed)
pool:
  name: WSL-Agent
  demands:
  - Agent.Name -equals Dell-Predator-G15-5530

# =========================================================
# Stage 1: Security Scans (Terrascan + Checkov) 
# Purpose: Run security vulnerability scans on Terraform modules
# Triggers: Runs on both CI builds and Pull Requests for early security feedback
# =========================================================
stages:
- stage: Security_Scans
  displayName: "Run Terrascan & Checkov Scans"
  jobs:
  - job: SecurityScanJob
    displayName: "Terraform Security Scan Job"
    steps:
      - checkout: self
      
      # Install required dependencies first
      - script: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y unzip curl
        displayName: "Install Dependencies (unzip, curl)"
      
      - task: TerraformInstaller@1
        displayName: "Install Latest Terraform"
        inputs:
          terraformVersion: "latest"

      # Install Terrascan security scanning tool (version 1.19.9)
      # - script: |
      #     set -e
      #     echo "Installing Terrascan v1.19.9..."
      #     curl -L https://github.com/tenable/terrascan/releases/download/v1.19.9/terrascan_1.19.9_Linux_x86_64.tar.gz -o terrascan.tar.gz
      #     tar -xvf terrascan.tar.gz terrascan
      #     sudo install terrascan /usr/local/bin
      #     rm -f terrascan terrascan.tar.gz
      #     terrascan version
      #   displayName: "Install Terrascan v1.19.9"

      # # Install Checkov security scanning tool via Python pip
      # - script: |
      #     set -e
      #     echo "Installing Checkov..."
      #     sudo apt-get update -y
      #     sudo apt-get install -y python3-pip
      #     pip3 install --break-system-packages --upgrade pip
      #     pip3 install --break-system-packages checkov
      #     # Add local bin to PATH for current and future commands
      #     export PATH="$HOME/.local/bin:$PATH"
      #     echo "##vso[task.setvariable variable=PATH]$HOME/.local/bin:$PATH"
      #     checkov -v
      #   displayName: "Install Checkov"

      # - script: |
      #     set -e
      #     echo "Creating artifact folder for scan results..."
      #     mkdir -p "$(System.DefaultWorkingDirectory)/scan-results"
      #     # Ensure local bin is in PATH for Checkov
      #     export PATH="$HOME/.local/bin:$PATH"
      #     export TERRASCAN_HCL_EXPERIMENTS="module_variable_optional_attrs"
      #     shopt -s nullglob
      #     for m in terraform/modules/*; do
      #       [ -d "$m" ] || continue
      #       name=$(basename "$m")
      #       echo "=== Scanning module: $name ==="
      #       (cd "$m" && terraform init -backend=false -input=false)
      #       module_path="$(Build.SourcesDirectory)/$m"
      #       terrascan scan -d "$module_path" \
      #         --policy-type azure \
      #         --iac-type terraform \
      #         --iac-version v14 \
      #         --output junit-xml \
      #         --show-passed > "$(System.DefaultWorkingDirectory)/scan-results/${name}-Terrascan-Report.xml" || true
      #       checkov -d "$module_path" -o junitxml > "$(System.DefaultWorkingDirectory)/scan-results/${name}-Checkov-Report.xml" || true
      #     done
      #   displayName: "Run Terrascan & Checkov on Modules"

      # - task: PublishTestResults@2
      #   displayName: "Publish JUnit Scan Results"
      #   inputs:
      #     testResultsFormat: "JUnit"  # Use JUnit XML format for test results
      #     testResultsFiles: "$(System.DefaultWorkingDirectory)/scan-results/*.xml"  # Include all XML files from scan results
      #     failTaskOnFailedTests: false  # Don't fail the pipeline if security issues are found (for visibility only)
      #     testRunTitle: "IaC Security Scans (Terrascan & Checkov)"  # Display name for test results

# =========================================================
# Stage 2: Prepare (Plan) - Terraform Planning and Artifact Creation
# Purpose: Generate Terraform execution plan and package artifacts for deployment
# Triggers: Only runs after merge to main branch (not on Pull Requests)
# Outputs: 
#   - terraform-files artifact: Complete Terraform configuration
#   - tfplan artifact: Binary Terraform plan file for exact deployment
# =========================================================
- stage: Prepare_Terraform_Release
  displayName: "Prepare Artifact for Release"
  dependsOn: Security_Scans

  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/integrations-networking'), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - job: Deployment
    displayName: "Terraform Deployment"
    steps:
      - checkout: self
      - task: Bash@3
        displayName: "Export Storage Backend Variables (no secrets)"
        inputs:
          targetType: inline
          script: |
            # Set pipeline variables from variable group for Terraform backend configuration
            echo "##vso[task.setvariable variable=TF_STORAGE_RESOURCE_GROUP]$(TF_STORAGE_RESOURCE_GROUP)"
            echo "##vso[task.setvariable variable=TF_STORAGE_ACCOUNT_NAME]$(TF_STORAGE_ACCOUNT_NAME)"
            echo "##vso[task.setvariable variable=TF_CONTAINER_NAME]$(TF_CONTAINER_NAME)"

      - script: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq unzip curl rsync
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        displayName: "Install Dependencies"

      # Verify Azure CLI was installed correctly
      - script: |
          az --version
        displayName: "Verify Azure CLI Installation"

      # Install Terraform CLI at the specified version
      - task: TerraformInstaller@1
        displayName: "Install Terraform"
        inputs:
          terraformVersion: "$(TERRAFORM_VERSION)"  # Use version defined in pipeline variables

      # Create backend configuration file for Terraform state storage
      # Backend always uses the dedicated backend subscription for centralized state management
      - script: |
          # Disable command echo for security (hides sensitive variable values)
          set +x
          # Create backend configuration file with Azure AD authentication
          cat > "$(Build.SourcesDirectory)/terraform/backend.tfvars" <<EOF
          subscription_id      = "$(SUBSCRIPTION_ID_BACKEND)"    # Backend subscription for state storage
          resource_group_name  = "$(TF_STORAGE_RESOURCE_GROUP)"  # Resource group containing storage account
          storage_account_name = "$(TF_STORAGE_ACCOUNT_NAME)"    # Storage account for Terraform state
          container_name       = "$(TF_CONTAINER_NAME)"          # Blob container for state files
          key                  = "lnt-eip-${{ parameters.environment }}.tfstate"  # State file name per environment
          use_azuread_auth     = true                            # Use Azure AD for authentication
          EOF
          # Re-enable command echo
          set -x
        displayName: "Write Backend Configuration (Azure AD auth - Backend subscription)"

      # Debug: Show backend configuration
      - script: |
          echo "=== Backend Configuration Content ==="
          cat "$(Build.SourcesDirectory)/terraform/backend.tfvars"
          echo ""
        displayName: "Debug: Show backend.tfvars content"

      # Debug: List directory structure to verify environments folder exists and tfvars file is present
      - script: |
          echo "=== Listing terraform directory structure ==="
          ls -la "$(Build.SourcesDirectory)/terraform/"
          echo ""
          echo "=== Checking if environments folder exists ==="
          if [ -d "$(Build.SourcesDirectory)/terraform/environments" ]; then
            echo "environments/ folder exists"
            ls -la "$(Build.SourcesDirectory)/terraform/environments/"
          else
            echo "ERROR: environments/ folder not found!"
            exit 1
          fi
          echo ""
          echo "=== Checking if ${{ parameters.environment }}.tfvars exists ==="
          if [ -f "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars" ]; then
            echo "${{ parameters.environment }}.tfvars file exists"
            echo "File size: $(stat -f%z "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars" 2>/dev/null || stat -c%s "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars" 2>/dev/null || echo 'unknown')"
          else
            echo "ERROR: ${{ parameters.environment }}.tfvars file not found!"
            exit 1
          fi
        displayName: "Debug: Verify environments folder and tfvars file"

      # Configure provider authentication by appending environment-specific subscription info
      - script: |
          # Disable command echo for security
          set +x
          # Verify file exists before appending
          if [ ! -f "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars" ]; then
            echo "ERROR: environments/${{ parameters.environment }}.tfvars does not exist"
            exit 1
          fi
          {
            echo 'tenant_id       = "$(TENANT_ID)"'
            echo 'subscription_id = "$(SUBSCRIPTION_ID_${{ parameters.environment }})"'  # Target environment subscription
          } >> "$(Build.SourcesDirectory)/terraform/environments/${{ parameters.environment }}.tfvars"
          set -x
          echo "Successfully appended auth variables to environments/${{ parameters.environment }}.tfvars"
        displayName: "Append Non-Secret Auth Variables for Provider"

      # Step 1: Initialize Terraform with backend configuration (uses Backend subscription for state)
      - task: AzureCLI@2
        displayName: "Terraform Init"
        inputs:
          azureSubscription: "svc-enterprise-integrations"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            # Exit on any error
            set -e
            az account set --subscription $(SUBSCRIPTION_ID_BACKEND)
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1  # Optimize Terraform for CI/CD environments
            echo "Account for backend (state storage):"
            az account show --query "{name:name, sub:id, tenant:tenantId}" -o tsv
            terraform -version
            terraform init -backend-config=backend.tfvars -reconfigure

      # Step 2: Validate Terraform configuration syntax and consistency
      - task: AzureCLI@2
        displayName: "Terraform Validate"
        inputs:
          azureSubscription: "svc-enterprise-integrations"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            set -e
            # Ensure we're using Backend subscription for backend access
            az account set --subscription $(SUBSCRIPTION_ID_BACKEND)
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1

            # Validate Terraform configuration files for syntax errors and consistency
            terraform validate -no-color

      - task: AzureCLI@2
        displayName: "Terraform Plan"
        inputs:
          azureSubscription: "svc-enterprise-integrations"
          scriptType: "bash"
          scriptLocation: "inlineScript"
          workingDirectory: "$(Build.SourcesDirectory)/terraform"
          inlineScript: |
            # Exit on any error
            set -e
            # Set backend context to Backend subscription for state access
            az account set --subscription $(SUBSCRIPTION_ID_BACKEND)
            # Configure Azure provider authentication
            export ARM_TENANT_ID=$(TENANT_ID)
            export TF_IN_AUTOMATION=1

            # Generate execution plan with environment-specific configuration
            terraform plan \
              -var-file="environments/${{ parameters.environment }}.tfvars" \
              -input=false \
              -out=tfplan
            terraform show -no-color tfplan > tfplan.txt

      - task: Bash@3
        displayName: "Stage plan & config for artifacts"
        inputs:
          targetType: inline
          script: |
            # Exit on any error
            set -e
            # Create directory for the binary plan artifact
            mkdir -p "$(Build.ArtifactStagingDirectory)/tfplan"
            # Copy the saved plan file to artifact staging
            cp "$(Build.SourcesDirectory)/terraform/tfplan" "$(Build.ArtifactStagingDirectory)/tfplan/"
            cp "$(Build.SourcesDirectory)/terraform/tfplan.txt" "$(Build.ArtifactStagingDirectory)/tfplan/"
            mkdir -p "$(Build.ArtifactStagingDirectory)/terraform-files"
            # Sync all Terraform files except local state and plan files
            # --delete: Remove files in destination that don't exist in source
            # --exclude: Skip unnecessary files that shouldn't be in the artifact
            rsync -a --delete \
              --exclude '.terraform/' \
              --exclude '*.plan' \
              "$(Build.SourcesDirectory)/terraform/" \
              "$(Build.ArtifactStagingDirectory)/terraform-files/"

      - task: PublishPipelineArtifact@1
        displayName: "Publish Pipeline Artifact: terraform-files"
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)/terraform-files"
          artifact: "terraform-files"
          publishLocation: "pipeline"

      # Publish Terraform execution plan as a separate pipeline artifact
      - task: PublishPipelineArtifact@1
        displayName: "Publish Pipeline Artifact: tfplan"
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)/tfplan"
          artifact: "tfplan"
          publishLocation: "pipeline"

# =========================================================
# Stage 3: Terraform Apply - Execute Infrastructure Changes
# Purpose: Apply the saved Terraform plan to deploy infrastructure changes
# Triggers: Only runs after successful Plan stage on main branch (not PRs)
# Security: Bound to Azure DevOps Environment for manual approvals and deployment gates
# =========================================================
- stage: Terraform_Apply
  displayName: "Terraform Apply"
  dependsOn: Prepare_Terraform_Release
  # Only run if: Plan stage succeeded AND this is main branch build AND not a PR
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/integrations-networking'), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - deployment: ApplyDeployment
    displayName: "Apply Terraform Changes"
    # Bind this deployment to an Azure DevOps Environment for approval workflows
    # Environment name format: MR-Approval-{environment} (e.g., MR-Approval-dev, MR-Approval-prd)
    # Configure approvals and checks in Azure DevOps Pipelines > Environments
    environment: "MR-Approval-${{ parameters.environment }}"
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: none

            - task: DownloadPipelineArtifact@2
              displayName: "Download terraform-files"
              inputs:
                buildType: current
                artifact: "terraform-files"
                targetPath: "$(Pipeline.Workspace)/terraform-files"

            - task: DownloadPipelineArtifact@2
              displayName: "Download tfplan"
              inputs:
                buildType: current
                artifact: "tfplan"
                targetPath: "$(Pipeline.Workspace)/tfplan"

            - script: |
                set -e
                sudo apt-get update -y
                sudo apt-get install -y jq unzip curl  # JSON processor, archive tools, HTTP client
                curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
              displayName: "Install Dependencies (Azure CLI, tools)"

            - script: |
                az --version
              displayName: "Verify Azure CLI Installation"

            - task: TerraformInstaller@1
              displayName: "Install Terraform (Apply Stage)"
              inputs:
                terraformVersion: "$(TERRAFORM_VERSION)"

            - script: |
                set +x
                cat > "$(Pipeline.Workspace)/terraform-files/backend.tfvars" <<EOF
                subscription_id      = "$(SUBSCRIPTION_ID_BACKEND)"
                resource_group_name  = "$(TF_STORAGE_RESOURCE_GROUP)"
                storage_account_name = "$(TF_STORAGE_ACCOUNT_NAME)"
                container_name       = "$(TF_CONTAINER_NAME)"
                key                  = "lnt-eip-${{ parameters.environment }}.tfstate"
                use_azuread_auth     = true
                EOF
                # Re-enable command echo
                set -x
              displayName: "Write Backend Configuration (Azure AD auth - Backend subscription)"

            - task: AzureCLI@2
              displayName: "Terraform Init (backend storage)"
              inputs:
                azureSubscription: "svc-enterprise-integrations"
                scriptType: "bash"
                scriptLocation: "inlineScript"
                workingDirectory: "$(Pipeline.Workspace)/terraform-files"
                inlineScript: |
                  # Exit on any error
                  set -e
                  az account set --subscription $(SUBSCRIPTION_ID_BACKEND)
                  export ARM_TENANT_ID=$(TENANT_ID)
                  export TF_IN_AUTOMATION=1  # Optimize for CI/CD environment
                  echo "Account for backend (state storage):"
                  az account show --query "{name:name, sub:id, tenant:tenantId}" -o tsv
                  terraform -version
                  terraform init -backend-config=backend.tfvars -reconfigure

            - task: AzureCLI@2
              displayName: "Terraform Show (saved plan)"
              inputs:
                azureSubscription: "svc-enterprise-integrations"
                scriptType: "bash"
                scriptLocation: "inlineScript"
                workingDirectory: "$(Pipeline.Workspace)/terraform-files"
                inlineScript: |
                  set -e
                  terraform show -no-color "$(Pipeline.Workspace)/tfplan/tfplan" | tee plan.txt


            - task: PublishPipelineArtifact@1
              displayName: "Publish Plan Text for Audit"
              inputs:
                targetPath: "$(Pipeline.Workspace)/terraform-files/plan.txt"
                artifact: "tfplan-text"
                publishLocation: "pipeline"

            # Execute the saved Terraform plan to apply infrastructure changes
            - task: AzureCLI@2
              displayName: "Terraform Apply (using saved plan)"
              inputs:
                azureSubscription: "svc-enterprise-integrations"
                scriptType: "bash"
                scriptLocation: "inlineScript"
                workingDirectory: "$(Pipeline.Workspace)/terraform-files"
                inlineScript: |

                  set -e
                  az account set --subscription $(SUBSCRIPTION_ID_BACKEND)
                  export ARM_TENANT_ID=$(TENANT_ID)
                  export TF_IN_AUTOMATION=1
                  terraform apply -input=false -auto-approve "$(Pipeline.Workspace)/tfplan/tfplan"